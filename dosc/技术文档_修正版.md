# æ”¶è—æ’ä»¶ - æŠ€æœ¯æ–‡æ¡£ï¼ˆä¿®æ­£ç‰ˆï¼‰

## 1. é¡¹ç›®æ¦‚è¿°

### 1.1 é¡¹ç›®ç®€ä»‹
ä¸€æ¬¾åŸºäº Chrome Extension Manifest V3 çš„ç°ä»£åŒ–æµè§ˆå™¨æ‰©å±•æ’ä»¶ï¼Œé‡‡ç”¨ React + TypeScript + Tailwind CSS æŠ€æœ¯æ ˆï¼Œæä¾›å¿«é€Ÿæ”¶è—ç½‘é¡µã€æ™ºèƒ½æ ‡ç­¾ç®¡ç†ã€æ•°æ®å¯è§†åŒ–å’Œçµæ´»å¯¼å‡ºç­‰åŠŸèƒ½ã€‚æ‰€æœ‰æ•°æ®ä½¿ç”¨ Chrome Storage API è¿›è¡Œæœ¬åœ°å­˜å‚¨ã€‚

### 1.2 æŠ€æœ¯æ ˆ
- **æ¡†æ¶**: React 19 + TypeScript 5.x
- **æ ·å¼**: Tailwind CSS 3.x + CSS Modules
- **æ„å»ºå·¥å…·**: Vite 6.x + CRXJS
- **çŠ¶æ€ç®¡ç†**: Zustand / Context API
- **æ•°æ®å¯è§†åŒ–**: Recharts / Tremor
- **å­˜å‚¨æ–¹æ¡ˆ**: Chrome Storage Local API (chrome.storage.local)
- **æµè§ˆå™¨API**: Chrome Extension Manifest V3
- **å¼€å‘å·¥å…·**: Biome (æ ¼å¼åŒ–å’Œæ£€æŸ¥)ã€Vitest (æµ‹è¯•)
- **ç±»å‹å®‰å…¨**: Zod (è¿è¡Œæ—¶éªŒè¯)

## 2. ç³»ç»Ÿæ¶æ„

### 2.1 æ•´ä½“æ¶æ„ï¼ˆManifest V3ï¼‰
```
â”œâ”€â”€ manifest.json          # Manifest V3 é…ç½®
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ popup/            # å¼¹çª—åº”ç”¨ (React)
â”‚   â”‚   â”œâ”€â”€ App.tsx
â”‚   â”‚   â”œâ”€â”€ main.tsx
â”‚   â”‚   â””â”€â”€ index.html
â”‚   â”œâ”€â”€ options/          # è®¾ç½®é¡µé¢ (React)
â”‚   â”‚   â”œâ”€â”€ App.tsx
â”‚   â”‚   â”œâ”€â”€ main.tsx
â”‚   â”‚   â””â”€â”€ index.html
â”‚   â”œâ”€â”€ background/       # Service Worker
â”‚   â”‚   â””â”€â”€ service-worker.ts
â”‚   â”œâ”€â”€ content/          # å†…å®¹è„šæœ¬
â”‚   â”‚   â””â”€â”€ content.ts
â”‚   â”œâ”€â”€ components/       # å…±äº«Reactç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ BookmarkForm/
â”‚   â”‚   â”œâ”€â”€ TagInput/
â”‚   â”‚   â””â”€â”€ Dashboard/
â”‚   â”œâ”€â”€ hooks/            # è‡ªå®šä¹‰React Hooks
â”‚   â”‚   â”œâ”€â”€ useBookmarks.ts
â”‚   â”‚   â”œâ”€â”€ useTags.ts
â”‚   â”‚   â””â”€â”€ useStorage.ts
â”‚   â”œâ”€â”€ stores/           # çŠ¶æ€ç®¡ç†
â”‚   â”‚   â””â”€â”€ bookmarkStore.ts
â”‚   â”œâ”€â”€ lib/              # å·¥å…·å‡½æ•°
â”‚   â”‚   â”œâ”€â”€ storage.ts
â”‚   â”‚   â”œâ”€â”€ utils.ts
â”‚   â”‚   â””â”€â”€ export.ts
â”‚   â””â”€â”€ types/            # TypeScriptç±»å‹å®šä¹‰
â”‚       â””â”€â”€ index.ts
â”œâ”€â”€ public/               # é™æ€èµ„æº
â”‚   â””â”€â”€ icons/           # å›¾æ ‡æ–‡ä»¶
â”œâ”€â”€ dist/                # æ„å»ºè¾“å‡º
â”œâ”€â”€ tailwind.config.ts    # Tailwindé…ç½®
â”œâ”€â”€ vite.config.ts        # Viteé…ç½®
â”œâ”€â”€ tsconfig.json         # TypeScripté…ç½®
â””â”€â”€ package.json          # é¡¹ç›®ä¾èµ–

```

### 2.2 æ•°æ®æµæ¶æ„ï¼ˆReact + Service Workerï¼‰
- **ç»„ä»¶é€šä¿¡**: React Context + Custom Hooks
- **è·¨é¡µé¢é€šä¿¡**: Chrome Runtime Message API
- **çŠ¶æ€åŒæ­¥**: chrome.storage.onChanged ç›‘å¬å™¨
- **æ•°æ®å­˜å‚¨**: chrome.storage.local æœ¬åœ°å­˜å‚¨
- **åå°å¤„ç†**: Service Worker å¤„ç†æŒä¹…åŒ–ä»»åŠ¡

## 3. æ ¸å¿ƒæ¨¡å—è®¾è®¡

### 3.1 ç±»å‹å®šä¹‰ï¼ˆå®Œæ•´ç‰ˆï¼‰

```typescript
// src/types/index.ts
export interface Bookmark {
  id: string;
  url: string;
  title: string;
  note: string;
  tags: string[];
  createdAt: string;
  updatedAt?: string;
  deleted?: boolean;
  deletedAt?: string;
  favicon?: string;
}

export interface Tag {
  id: string;
  name: string;
  count: number;
  color?: string;
  createdAt: string;
}

export interface StorageData {
  bookmarks: Bookmark[];
  tags: Record<string, Tag>;
  settings: {
    version: string;
    theme?: 'light' | 'dark' | 'auto';
    dashboardCollapsed?: boolean;
  };
}

// ä½¿ç”¨Zodè¿›è¡Œè¿è¡Œæ—¶éªŒè¯
import { z } from 'zod';

export const BookmarkSchema = z.object({
  id: z.string().uuid(),
  url: z.string().url(),
  title: z.string().min(1),
  note: z.string(),
  tags: z.array(z.string()),
  createdAt: z.string().datetime(),
  updatedAt: z.string().datetime().optional(),
  deleted: z.boolean().optional(),
  deletedAt: z.string().datetime().optional(),
  favicon: z.string().optional()
});

export type BookmarkInput = z.infer<typeof BookmarkSchema>;
```

### 3.2 å·¥å…·å‡½æ•°ï¼ˆå®Œæ•´ç‰ˆï¼‰

```typescript
// src/lib/utils.ts
import { type ClassValue, clsx } from 'clsx';
import { twMerge } from 'tailwind-merge';

// åˆå¹¶Tailwind CSSç±»å
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

// ç”Ÿæˆå”¯ä¸€ID
export function generateId(): string {
  return crypto.randomUUID();
}

// æ ‡ç­¾è§„èŒƒåŒ–
export function normalizeTag(tag: string): string {
  return tag.toLowerCase().trim();
}

// CSVå­—æ®µè½¬ä¹‰
export function escapeCSV(text: string): string {
  if (!text) return '';

  // å¦‚æœåŒ…å«é€—å·ã€å¼•å·æˆ–æ¢è¡Œï¼Œéœ€è¦ç”¨å¼•å·åŒ…è£¹
  if (text.includes(',') || text.includes('"') || text.includes('\n')) {
    return `"${text.replace(/"/g, '""')}"`;
  }

  return text;
}

// é˜²æŠ–å‡½æ•°
export function debounce<T extends (...args: any[]) => any>(
  func: T,
  wait: number
): (...args: Parameters<T>) => void {
  let timeout: NodeJS.Timeout;

  return function (...args: Parameters<T>) {
    clearTimeout(timeout);
    timeout = setTimeout(() => func(...args), wait);
  };
}

// æ ¼å¼åŒ–æ—¥æœŸ
export function formatDate(dateString: string): string {
  const date = new Date(dateString);
  return date.toLocaleDateString('zh-CN', {
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit'
  });
}
```

### 3.3 å­˜å‚¨å±‚å°è£…ï¼ˆChrome Storage Localï¼‰

```typescript
// src/lib/storage.ts
import { Bookmark, Tag, StorageData } from '@/types';

export class StorageManager {
  static STORAGE_KEYS = {
    BOOKMARKS: 'bookmarks',
    TAGS: 'tags',
    SETTINGS: 'settings'
  } as const;

  // é€šç”¨è·å–æ–¹æ³•
  static async get<K extends keyof StorageData>(
    key: K
  ): Promise<StorageData[K] | null> {
    return new Promise((resolve) => {
      chrome.storage.local.get([key], (result) => {
        resolve(result[key] || null);
      });
    });
  }

  // é€šç”¨è®¾ç½®æ–¹æ³•
  static async set<K extends keyof StorageData>(
    key: K,
    value: StorageData[K]
  ): Promise<void> {
    return new Promise((resolve, reject) => {
      chrome.storage.local.set({ [key]: value }, () => {
        if (chrome.runtime.lastError) {
          reject(chrome.runtime.lastError);
        } else {
          resolve();
        }
      });
    });
  }

  // è·å–æ‰€æœ‰ä¹¦ç­¾ï¼ˆè¿‡æ»¤å·²åˆ é™¤çš„ï¼‰
  static async getBookmarks(): Promise<Bookmark[]> {
    const bookmarks = await this.get('bookmarks') || [];
    return bookmarks.filter(b => !b.deleted);
  }

  // è·å–æ‰€æœ‰ä¹¦ç­¾ï¼ˆåŒ…æ‹¬å·²åˆ é™¤çš„ï¼‰
  static async getAllBookmarks(): Promise<Bookmark[]> {
    return await this.get('bookmarks') || [];
  }

  // ä¿å­˜å•ä¸ªä¹¦ç­¾
  static async saveBookmark(bookmark: Bookmark): Promise<void> {
    const bookmarks = await this.getAllBookmarks();

    const existingIndex = bookmarks.findIndex(b => b.id === bookmark.id);
    if (existingIndex >= 0) {
      bookmarks[existingIndex] = {
        ...bookmark,
        updatedAt: new Date().toISOString()
      };
    } else {
      bookmarks.push(bookmark);
    }

    await this.set('bookmarks', bookmarks);

    // æ›´æ–°æ ‡ç­¾ç»Ÿè®¡
    await this.updateTagStats(bookmark.tags);
  }

  // æ‰¹é‡ä¿å­˜ä¹¦ç­¾
  static async saveBookmarks(bookmarks: Bookmark[]): Promise<void> {
    await this.set('bookmarks', bookmarks);
  }

  // åˆ é™¤ä¹¦ç­¾ï¼ˆæ”¯æŒè½¯åˆ é™¤ï¼‰
  static async deleteBookmark(id: string, soft = true): Promise<void> {
    const bookmarks = await this.getAllBookmarks();

    if (soft) {
      const index = bookmarks.findIndex(b => b.id === id);
      if (index >= 0) {
        bookmarks[index] = {
          ...bookmarks[index],
          deleted: true,
          deletedAt: new Date().toISOString()
        };
      }
    } else {
      const filtered = bookmarks.filter(b => b.id !== id);
      await this.set('bookmarks', filtered);
      return;
    }

    await this.set('bookmarks', bookmarks);
  }

  // æ‰¹é‡åˆ é™¤ä¹¦ç­¾
  static async deleteBookmarks(ids: string[], soft = true): Promise<void> {
    const bookmarks = await this.getAllBookmarks();

    const updatedBookmarks = bookmarks.map(bookmark => {
      if (ids.includes(bookmark.id)) {
        if (soft) {
          return {
            ...bookmark,
            deleted: true,
            deletedAt: new Date().toISOString()
          };
        }
        return null;
      }
      return bookmark;
    }).filter(Boolean) as Bookmark[];

    await this.set('bookmarks', updatedBookmarks);
  }

  // æ›´æ–°æ ‡ç­¾ç»Ÿè®¡
  static async updateTagStats(tags: string[]): Promise<void> {
    const allTags = await this.get('tags') || {};

    tags.forEach(tag => {
      const normalizedTag = tag.toLowerCase().trim();
      if (!allTags[normalizedTag]) {
        allTags[normalizedTag] = {
          id: crypto.randomUUID(),
          name: normalizedTag,
          count: 0,
          createdAt: new Date().toISOString()
        };
      }
      allTags[normalizedTag].count++;
    });

    await this.set('tags', allTags);
  }

  // è·å–æ‰€æœ‰æ ‡ç­¾
  static async getTags(): Promise<Tag[]> {
    const tags = await this.get('tags') || {};
    return Object.values(tags);
  }

  // æ¸…ç©ºæ‰€æœ‰æ•°æ®
  static async clearAll(): Promise<void> {
    await chrome.storage.local.clear();
  }

  // è·å–å­˜å‚¨ä½¿ç”¨æƒ…å†µ
  static async getStorageInfo(): Promise<{
    bytesInUse: number;
    quota: number;
  }> {
    return new Promise((resolve) => {
      chrome.storage.local.getBytesInUse(null, (bytesInUse) => {
        // Chromeæœ¬åœ°å­˜å‚¨é…é¢çº¦ä¸º5MB
        resolve({
          bytesInUse,
          quota: chrome.storage.local.QUOTA_BYTES || 5242880 // 5MB
        });
      });
    });
  }
}
```

### 3.4 è‡ªå®šä¹‰Hooksï¼ˆå®Œæ•´å®ç°ï¼‰

#### 3.4.1 useStorage Hook
```typescript
// src/hooks/useStorage.ts
import { useState, useEffect, useCallback } from 'react';

export function useStorage<T>(key: string, initialValue: T) {
  const [value, setValue] = useState<T>(initialValue);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  // åˆå§‹åŠ è½½
  useEffect(() => {
    chrome.storage.local.get([key], (result) => {
      if (chrome.runtime.lastError) {
        setError(new Error(chrome.runtime.lastError.message));
      } else if (result[key] !== undefined) {
        setValue(result[key]);
      }
      setLoading(false);
    });
  }, [key]);

  // ç›‘å¬å­˜å‚¨å˜åŒ–
  useEffect(() => {
    const listener = (
      changes: { [key: string]: chrome.storage.StorageChange },
      areaName: string
    ) => {
      if (areaName === 'local' && changes[key]) {
        setValue(changes[key].newValue);
      }
    };

    chrome.storage.onChanged.addListener(listener);
    return () => chrome.storage.onChanged.removeListener(listener);
  }, [key]);

  // æ›´æ–°å€¼
  const updateValue = useCallback(async (newValue: T | ((prev: T) => T)) => {
    const finalValue = typeof newValue === 'function'
      ? (newValue as (prev: T) => T)(value)
      : newValue;

    try {
      await chrome.storage.local.set({ [key]: finalValue });
      setValue(finalValue);
      setError(null);
    } catch (err) {
      setError(err as Error);
    }
  }, [key, value]);

  // åˆ é™¤å€¼
  const removeValue = useCallback(async () => {
    try {
      await chrome.storage.local.remove(key);
      setValue(initialValue);
      setError(null);
    } catch (err) {
      setError(err as Error);
    }
  }, [key, initialValue]);

  return {
    value,
    setValue: updateValue,
    removeValue,
    loading,
    error
  };
}
```

#### 3.4.2 useBookmarks Hook
```typescript
// src/hooks/useBookmarks.ts
import { useState, useEffect, useCallback } from 'react';
import { Bookmark } from '@/types';
import { StorageManager } from '@/lib/storage';

export function useBookmarks() {
  const [bookmarks, setBookmarks] = useState<Bookmark[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  // åŠ è½½ä¹¦ç­¾
  const loadBookmarks = useCallback(async () => {
    try {
      setLoading(true);
      const data = await StorageManager.getBookmarks();
      setBookmarks(data);
      setError(null);
    } catch (err) {
      setError(err as Error);
    } finally {
      setLoading(false);
    }
  }, []);

  // åˆå§‹åŠ è½½
  useEffect(() => {
    loadBookmarks();
  }, [loadBookmarks]);

  // ç›‘å¬å­˜å‚¨å˜åŒ–
  useEffect(() => {
    const listener = (
      changes: { [key: string]: chrome.storage.StorageChange },
      areaName: string
    ) => {
      if (areaName === 'local' && changes.bookmarks) {
        const newBookmarks = changes.bookmarks.newValue || [];
        setBookmarks(newBookmarks.filter((b: Bookmark) => !b.deleted));
      }
    };

    chrome.storage.onChanged.addListener(listener);
    return () => chrome.storage.onChanged.removeListener(listener);
  }, []);

  // æ·»åŠ ä¹¦ç­¾
  const addBookmark = useCallback(async (bookmark: Bookmark) => {
    try {
      await StorageManager.saveBookmark(bookmark);
      await loadBookmarks(); // é‡æ–°åŠ è½½ä»¥è·å–æœ€æ–°æ•°æ®
    } catch (err) {
      setError(err as Error);
      throw err;
    }
  }, [loadBookmarks]);

  // æ›´æ–°ä¹¦ç­¾
  const updateBookmark = useCallback(async (bookmark: Bookmark) => {
    try {
      await StorageManager.saveBookmark({
        ...bookmark,
        updatedAt: new Date().toISOString()
      });
      await loadBookmarks();
    } catch (err) {
      setError(err as Error);
      throw err;
    }
  }, [loadBookmarks]);

  // åˆ é™¤ä¹¦ç­¾
  const deleteBookmark = useCallback(async (id: string, soft = true) => {
    try {
      await StorageManager.deleteBookmark(id, soft);
      await loadBookmarks();
    } catch (err) {
      setError(err as Error);
      throw err;
    }
  }, [loadBookmarks]);

  // æ‰¹é‡åˆ é™¤
  const deleteBookmarks = useCallback(async (ids: string[], soft = true) => {
    try {
      await StorageManager.deleteBookmarks(ids, soft);
      await loadBookmarks();
    } catch (err) {
      setError(err as Error);
      throw err;
    }
  }, [loadBookmarks]);

  return {
    bookmarks,
    loading,
    error,
    addBookmark,
    updateBookmark,
    deleteBookmark,
    deleteBookmarks,
    refresh: loadBookmarks
  };
}
```

#### 3.4.3 useTags Hook
```typescript
// src/hooks/useTags.ts
import { useState, useEffect, useCallback } from 'react';
import { Tag } from '@/types';
import { StorageManager } from '@/lib/storage';

export function useTags() {
  const [tags, setTags] = useState<Tag[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  // åŠ è½½æ ‡ç­¾
  const loadTags = useCallback(async () => {
    try {
      setLoading(true);
      const data = await StorageManager.getTags();
      setTags(data);
      setError(null);
    } catch (err) {
      setError(err as Error);
    } finally {
      setLoading(false);
    }
  }, []);

  // åˆå§‹åŠ è½½
  useEffect(() => {
    loadTags();
  }, [loadTags]);

  // ç›‘å¬å­˜å‚¨å˜åŒ–
  useEffect(() => {
    const listener = (
      changes: { [key: string]: chrome.storage.StorageChange },
      areaName: string
    ) => {
      if (areaName === 'local' && changes.tags) {
        const newTags = changes.tags.newValue || {};
        setTags(Object.values(newTags));
      }
    };

    chrome.storage.onChanged.addListener(listener);
    return () => chrome.storage.onChanged.removeListener(listener);
  }, []);

  // æ·»åŠ æ ‡ç­¾
  const addTag = useCallback(async (tagName: string) => {
    try {
      await StorageManager.updateTagStats([tagName]);
      await loadTags();
    } catch (err) {
      setError(err as Error);
      throw err;
    }
  }, [loadTags]);

  return {
    tags,
    loading,
    error,
    addTag,
    refresh: loadTags
  };
}
```

#### 3.4.4 useCurrentTab Hook
```typescript
// src/hooks/useCurrentTab.ts
import { useState, useEffect } from 'react';

interface Tab extends chrome.tabs.Tab {
  // æ‰©å±•chrome.tabs.Tabç±»å‹
}

export function useCurrentTab() {
  const [tab, setTab] = useState<Tab | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    chrome.tabs.query({ active: true, currentWindow: true }, ([currentTab]) => {
      if (currentTab) {
        setTab(currentTab);
      }
      setLoading(false);
    });
  }, []);

  return { tab, loading };
}
```

#### 3.4.5 useDebouncedValue Hook
```typescript
// src/hooks/useDebouncedValue.ts
import { useState, useEffect } from 'react';

export function useDebouncedValue<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}
```

### 3.5 Popupå¼¹çª—æ¨¡å—ï¼ˆä¿®æ­£ç‰ˆï¼‰

```tsx
// src/popup/App.tsx
import React, { useState } from 'react';
import { BookmarkForm } from '@/components/BookmarkForm';
import { useCurrentTab } from '@/hooks/useCurrentTab';
import { Loader2 } from 'lucide-react';

export function PopupApp() {
  const [showForm, setShowForm] = useState(false);
  const { tab, loading } = useCurrentTab();

  if (loading) {
    return (
      <div className="w-[300px] h-[150px] flex items-center justify-center">
        <Loader2 className="animate-spin" />
      </div>
    );
  }

  if (showForm && tab) {
    return <BookmarkForm tab={tab} onClose={() => setShowForm(false)} />;
  }

  return (
    <div className="w-[300px] h-[150px] p-4 bg-white dark:bg-gray-900">
      <div className="flex flex-col items-center justify-center h-full space-y-4">
        <button
          onClick={() => setShowForm(true)}
          disabled={!tab?.url}
          className="flex items-center px-4 py-2 text-white bg-blue-500 rounded-lg
                     hover:bg-blue-600 transition-colors duration-200
                     disabled:opacity-50 disabled:cursor-not-allowed"
        >
          <span className="mr-2">+</span>
          æ”¶è—å½“å‰ç½‘é¡µ
        </button>

        <a
          href="#"
          onClick={(e) => {
            e.preventDefault();
            chrome.tabs.create({ url: chrome.runtime.getURL('src/options/index.html') });
          }}
          className="text-blue-500 hover:text-blue-700 underline text-sm"
        >
          è¿›å…¥ç®¡ç†åå°
        </a>
      </div>
    </div>
  );
}
```

### 3.6 æ”¶è—è¡¨å•ç»„ä»¶ï¼ˆä¿®æ­£ç‰ˆï¼‰

```tsx
// src/components/BookmarkForm/BookmarkForm.tsx
import React, { useState } from 'react';
import { TagInput } from '@/components/TagInput';
import { useBookmarks } from '@/hooks/useBookmarks';
import { generateId } from '@/lib/utils';
import { Bookmark } from '@/types';
import { toast } from 'sonner';
import { Loader2 } from 'lucide-react';

interface BookmarkFormProps {
  tab: chrome.tabs.Tab;
  onClose: () => void;
  editingBookmark?: Bookmark;
}

export function BookmarkForm({ tab, onClose, editingBookmark }: BookmarkFormProps) {
  const { addBookmark, updateBookmark } = useBookmarks();
  const [loading, setLoading] = useState(false);
  const [formData, setFormData] = useState({
    title: editingBookmark?.title || tab.title || '',
    url: editingBookmark?.url || tab.url || '',
    note: editingBookmark?.note || '',
    tags: editingBookmark?.tags || []
  });

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    if (!formData.url || !formData.title) {
      toast.error('è¯·å¡«å†™å¿…è¦ä¿¡æ¯');
      return;
    }

    setLoading(true);

    const bookmark: Bookmark = {
      id: editingBookmark?.id || generateId(),
      ...formData,
      favicon: tab.favIconUrl,
      createdAt: editingBookmark?.createdAt || new Date().toISOString(),
      updatedAt: editingBookmark ? new Date().toISOString() : undefined
    };

    try {
      if (editingBookmark) {
        await updateBookmark(bookmark);
        toast.success('æ”¶è—å·²æ›´æ–°ï¼');
      } else {
        await addBookmark(bookmark);
        toast.success('æ”¶è—æˆåŠŸï¼');
      }

      setTimeout(onClose, 1500);
    } catch (error) {
      toast.error('æ“ä½œå¤±è´¥ï¼Œè¯·é‡è¯•');
      console.error(error);
    } finally {
      setLoading(false);
    }
  };

  return (
    <form onSubmit={handleSubmit} className="p-4 space-y-4 w-[400px]">
      <h2 className="text-lg font-semibold text-gray-900 dark:text-white">
        {editingBookmark ? 'ç¼–è¾‘æ”¶è—' : 'æ·»åŠ æ”¶è—'}
      </h2>

      {/* URLå­—æ®µï¼ˆåªè¯»ï¼‰ */}
      <div>
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
          ç½‘å€
        </label>
        <input
          type="url"
          value={formData.url}
          readOnly
          className="w-full px-3 py-2 bg-gray-100 border border-gray-300 rounded-lg
                     dark:bg-gray-800 dark:border-gray-600 text-gray-600 dark:text-gray-400"
        />
      </div>

      {/* æ ‡é¢˜å­—æ®µ */}
      <div>
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
          æ ‡é¢˜
        </label>
        <input
          type="text"
          value={formData.title}
          onChange={(e) => setFormData({ ...formData, title: e.target.value })}
          className="w-full px-3 py-2 border border-gray-300 rounded-lg
                     focus:outline-none focus:ring-2 focus:ring-blue-500
                     dark:bg-gray-800 dark:border-gray-600"
          required
        />
      </div>

      {/* å¤‡æ³¨å­—æ®µ */}
      <div>
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
          å¤‡æ³¨
        </label>
        <textarea
          value={formData.note}
          onChange={(e) => setFormData({ ...formData, note: e.target.value })}
          rows={5}
          className="w-full px-3 py-2 border border-gray-300 rounded-lg resize-y
                     focus:outline-none focus:ring-2 focus:ring-blue-500
                     dark:bg-gray-800 dark:border-gray-600"
          placeholder="æ·»åŠ å¤‡æ³¨..."
          autoFocus
        />
      </div>

      {/* æ ‡ç­¾è¾“å…¥ */}
      <div>
        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
          æ ‡ç­¾
        </label>
        <TagInput
          value={formData.tags}
          onChange={(tags) => setFormData({ ...formData, tags })}
        />
      </div>

      {/* æ“ä½œæŒ‰é’® */}
      <div className="flex justify-end space-x-3">
        <button
          type="button"
          onClick={onClose}
          disabled={loading}
          className="px-4 py-2 text-gray-700 bg-gray-200 rounded-lg
                     hover:bg-gray-300 dark:bg-gray-700 dark:text-gray-300
                     disabled:opacity-50"
        >
          å–æ¶ˆ
        </button>
        <button
          type="submit"
          disabled={loading}
          className="px-4 py-2 text-white bg-blue-500 rounded-lg
                     hover:bg-blue-600 transition-colors
                     disabled:opacity-50 flex items-center"
        >
          {loading && <Loader2 className="animate-spin mr-2" size={16} />}
          ç¡®è®¤ä¿å­˜
        </button>
      </div>
    </form>
  );
}
```

### 3.7 æœç´¢åˆ—è¡¨ç»„ä»¶ï¼ˆä¿®æ­£ç‰ˆï¼‰

```tsx
// src/components/BookmarkList/BookmarkList.tsx
import React, { useState, useMemo } from 'react';
import { useBookmarks } from '@/hooks/useBookmarks';
import { BookmarkCard } from './BookmarkCard';
import { Search, Trash2, Loader2 } from 'lucide-react';
import { useDebouncedValue } from '@/hooks/useDebouncedValue';

export function BookmarkList() {
  const { bookmarks, deleteBookmarks, loading, error } = useBookmarks();
  const [searchQuery, setSearchQuery] = useState('');
  const [selectedTag, setSelectedTag] = useState<string | null>(null);
  const [selectedBookmarks, setSelectedBookmarks] = useState<Set<string>>(new Set());
  const [isDeleting, setIsDeleting] = useState(false);

  const debouncedSearch = useDebouncedValue(searchQuery, 300);

  const filteredBookmarks = useMemo(() => {
    return bookmarks.filter(bookmark => {
      // æ ‡ç­¾ç­›é€‰
      if (selectedTag && !bookmark.tags.includes(selectedTag)) {
        return false;
      }

      // æœç´¢ç­›é€‰
      if (debouncedSearch) {
        const searchLower = debouncedSearch.toLowerCase();
        const searchableText = [
          bookmark.title,
          bookmark.note,
          ...bookmark.tags
        ].join(' ').toLowerCase();

        if (!searchableText.includes(searchLower)) {
          return false;
        }
      }

      return true;
    });
  }, [bookmarks, selectedTag, debouncedSearch]);

  const handleBatchDelete = async () => {
    if (selectedBookmarks.size === 0 || isDeleting) return;

    if (confirm(`ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${selectedBookmarks.size} æ¡è®°å½•å—ï¼Ÿ`)) {
      setIsDeleting(true);
      try {
        await deleteBookmarks(Array.from(selectedBookmarks), true);
        setSelectedBookmarks(new Set());
      } catch (error) {
        console.error('æ‰¹é‡åˆ é™¤å¤±è´¥:', error);
        alert('åˆ é™¤å¤±è´¥ï¼Œè¯·é‡è¯•');
      } finally {
        setIsDeleting(false);
      }
    }
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center h-64">
        <Loader2 className="animate-spin" size={32} />
      </div>
    );
  }

  if (error) {
    return (
      <div className="text-center py-8 text-red-500">
        åŠ è½½å¤±è´¥ï¼š{error.message}
      </div>
    );
  }

  return (
    <div className="space-y-4">
      {/* æœç´¢æ  */}
      <div className="relative">
        <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400" size={20} />
        <input
          type="text"
          value={searchQuery}
          onChange={(e) => setSearchQuery(e.target.value)}
          placeholder="æœç´¢æ ‡é¢˜ã€å¤‡æ³¨æˆ–æ ‡ç­¾..."
          className="w-full pl-10 pr-4 py-2 border border-gray-300 rounded-lg
                     focus:outline-none focus:ring-2 focus:ring-blue-500
                     dark:bg-gray-800 dark:border-gray-600"
        />
      </div>

      {/* æ‰¹é‡æ“ä½œæ  */}
      {selectedBookmarks.size > 0 && (
        <div className="flex items-center justify-between p-3 bg-blue-50 dark:bg-blue-900/20 rounded-lg">
          <span className="text-sm">
            å·²é€‰ä¸­ {selectedBookmarks.size} é¡¹
          </span>
          <button
            onClick={handleBatchDelete}
            disabled={isDeleting}
            className="flex items-center px-3 py-1 text-sm text-white bg-red-500 rounded
                       hover:bg-red-600 disabled:opacity-50"
          >
            {isDeleting ? (
              <Loader2 className="animate-spin mr-1" size={14} />
            ) : (
              <Trash2 size={14} className="mr-1" />
            )}
            æ‰¹é‡åˆ é™¤
          </button>
        </div>
      )}

      {/* æ”¶è—åˆ—è¡¨ */}
      <div className="space-y-3">
        {filteredBookmarks.length === 0 ? (
          <div className="text-center py-8 text-gray-500">
            {searchQuery || selectedTag ? 'æœªæ‰¾åˆ°ç›¸å…³æ”¶è—' : 'æš‚æ— æ”¶è—'}
          </div>
        ) : (
          filteredBookmarks.map(bookmark => (
            <BookmarkCard
              key={bookmark.id}
              bookmark={bookmark}
              selected={selectedBookmarks.has(bookmark.id)}
              onSelect={(selected) => {
                const newSet = new Set(selectedBookmarks);
                if (selected) {
                  newSet.add(bookmark.id);
                } else {
                  newSet.delete(bookmark.id);
                }
                setSelectedBookmarks(newSet);
              }}
            />
          ))
        )}
      </div>
    </div>
  );
}
```

### 3.8 Service Workerï¼ˆä¿®æ­£ç‰ˆï¼‰

```typescript
// src/background/service-worker.ts
/// <reference types="chrome" />

import { BookmarkSchema, type Bookmark } from '../types';
import { StorageManager } from '../lib/storage';

// åˆå§‹åŒ–æ‰©å±•
chrome.runtime.onInstalled.addListener(async (details) => {
  // åˆå§‹åŒ–å­˜å‚¨
  const storage = await chrome.storage.local.get(['bookmarks', 'tags', 'settings']);

  if (!storage.bookmarks) {
    await chrome.storage.local.set({ bookmarks: [] });
  }

  if (!storage.tags) {
    await chrome.storage.local.set({ tags: {} });
  }

  if (!storage.settings) {
    await chrome.storage.local.set({
      settings: {
        version: chrome.runtime.getManifest().version,
        theme: 'auto',
        dashboardCollapsed: false
      }
    });
  }

  // åˆ›å»ºå³é”®èœå•
  chrome.contextMenus.create({
    id: 'quick-save',
    title: 'å¿«é€Ÿæ”¶è—æ­¤é¡µ',
    contexts: ['page']
  });

  // å¦‚æœæ˜¯é¦–æ¬¡å®‰è£…ï¼Œæ‰“å¼€æ¬¢è¿é¡µé¢
  if (details.reason === 'install') {
    chrome.tabs.create({
      url: chrome.runtime.getURL('src/options/index.html')
    });
  }
});

// ç›‘å¬æ¥è‡ªpopupå’Œcontent scriptçš„æ¶ˆæ¯
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  // å¼‚æ­¥å¤„ç†æ¶ˆæ¯
  (async () => {
    try {
      switch (request.type) {
        case 'GET_BOOKMARKS':
          const bookmarks = await StorageManager.getBookmarks();
          sendResponse({ success: true, data: bookmarks });
          break;

        case 'SAVE_BOOKMARK':
          await StorageManager.saveBookmark(request.bookmark);
          sendResponse({ success: true });
          break;

        case 'DELETE_BOOKMARK':
          await StorageManager.deleteBookmark(request.id, request.soft ?? true);
          sendResponse({ success: true });
          break;

        case 'DELETE_BOOKMARKS':
          await StorageManager.deleteBookmarks(request.ids, request.soft ?? true);
          sendResponse({ success: true });
          break;

        case 'GET_TAGS':
          const tags = await StorageManager.getTags();
          sendResponse({ success: true, data: tags });
          break;

        case 'GET_STORAGE_INFO':
          const info = await StorageManager.getStorageInfo();
          sendResponse({ success: true, data: info });
          break;

        default:
          sendResponse({ success: false, error: 'Unknown message type' });
      }
    } catch (error) {
      console.error('Message handling error:', error);
      sendResponse({
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  })();

  // è¿”å›trueè¡¨ç¤ºå¼‚æ­¥å‘é€å“åº”
  return true;
});

// å¤„ç†å³é”®èœå•ç‚¹å‡»
chrome.contextMenus.onClicked.addListener(async (info, tab) => {
  if (info.menuItemId === 'quick-save' && tab?.url && tab?.title) {
    try {
      const bookmark: Bookmark = {
        id: crypto.randomUUID(),
        url: tab.url,
        title: tab.title,
        note: '',
        tags: ['å¿«é€Ÿæ”¶è—'],
        favicon: tab.favIconUrl,
        createdAt: new Date().toISOString()
      };

      await StorageManager.saveBookmark(bookmark);

      // æ˜¾ç¤ºé€šçŸ¥
      chrome.notifications.create({
        type: 'basic',
        iconUrl: chrome.runtime.getURL('icons/icon-128.png'),
        title: 'æ”¶è—æˆåŠŸ',
        message: `å·²æ”¶è—ï¼š${tab.title}`
      });
    } catch (error) {
      console.error('Quick save failed:', error);

      chrome.notifications.create({
        type: 'basic',
        iconUrl: chrome.runtime.getURL('icons/icon-128.png'),
        title: 'æ”¶è—å¤±è´¥',
        message: 'ä¿å­˜æ—¶å‘ç”Ÿé”™è¯¯ï¼Œè¯·é‡è¯•'
      });
    }
  }
});

// ç›‘å¬æ‰©å±•å›¾æ ‡ç‚¹å‡»ï¼ˆå¦‚æœæ²¡æœ‰è®¾ç½®popupï¼‰
chrome.action.onClicked.addListener((tab) => {
  // å¦‚æœmanifestä¸­æ²¡æœ‰è®¾ç½®default_popupï¼Œç‚¹å‡»å›¾æ ‡æ—¶æ‰“å¼€ç®¡ç†é¡µé¢
  chrome.tabs.create({
    url: chrome.runtime.getURL('src/options/index.html')
  });
});

// å®šæœŸæ¸…ç†å·²åˆ é™¤çš„ä¹¦ç­¾ï¼ˆå¯é€‰ï¼‰
chrome.alarms.create('cleanup', { periodInMinutes: 60 * 24 }); // æ¯24å°æ—¶

chrome.alarms.onAlarm.addListener(async (alarm) => {
  if (alarm.name === 'cleanup') {
    const bookmarks = await StorageManager.getAllBookmarks();
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

    // æ°¸ä¹…åˆ é™¤30å¤©å‰è½¯åˆ é™¤çš„ä¹¦ç­¾
    const cleaned = bookmarks.filter(b => {
      if (b.deleted && b.deletedAt) {
        const deletedDate = new Date(b.deletedAt);
        return deletedDate > thirtyDaysAgo;
      }
      return true;
    });

    if (cleaned.length < bookmarks.length) {
      await StorageManager.saveBookmarks(cleaned);
      console.log(`Cleaned ${bookmarks.length - cleaned.length} old deleted bookmarks`);
    }
  }
});
```

### 3.9 Manifest V3 é…ç½®ï¼ˆä¿®æ­£ç‰ˆï¼‰

```json
{
  "manifest_version": 3,
  "name": "æ™ºèƒ½æ”¶è—åŠ©æ‰‹",
  "version": "1.0.0",
  "description": "ç°ä»£åŒ–çš„ç½‘é¡µæ”¶è—ç®¡ç†å·¥å…·",

  "permissions": [
    "storage",
    "tabs",
    "contextMenus",
    "notifications",
    "alarms"
  ],

  "host_permissions": [
    "http://*/*",
    "https://*/*"
  ],

  "background": {
    "service_worker": "dist/background/service-worker.js",
    "type": "module"
  },

  "action": {
    "default_popup": "dist/popup/index.html",
    "default_icon": {
      "16": "icons/icon-16.png",
      "32": "icons/icon-32.png",
      "48": "icons/icon-48.png",
      "128": "icons/icon-128.png"
    },
    "default_title": "æ™ºèƒ½æ”¶è—åŠ©æ‰‹"
  },

  "options_page": "dist/options/index.html",

  "content_scripts": [
    {
      "matches": ["<all_urls>"],
      "js": ["dist/content/content.js"],
      "run_at": "document_idle"
    }
  ],

  "icons": {
    "16": "icons/icon-16.png",
    "32": "icons/icon-32.png",
    "48": "icons/icon-48.png",
    "128": "icons/icon-128.png"
  },

  "web_accessible_resources": [
    {
      "resources": ["dist/*", "icons/*"],
      "matches": ["<all_urls>"]
    }
  ]
}
```

### 3.10 Vite é…ç½®ï¼ˆä¿®æ­£ç‰ˆï¼‰

```typescript
// vite.config.ts
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import { crx } from '@crxjs/vite-plugin';
import manifest from './manifest.json';
import path from 'path';

export default defineConfig({
  plugins: [
    react(),
    crx({ manifest })
  ],

  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src')
    }
  },

  build: {
    outDir: 'dist',
    emptyOutDir: true,
    rollupOptions: {
      input: {
        popup: path.resolve(__dirname, 'src/popup/index.html'),
        options: path.resolve(__dirname, 'src/options/index.html'),
        background: path.resolve(__dirname, 'src/background/service-worker.ts'),
        content: path.resolve(__dirname, 'src/content/content.ts')
      },
      output: {
        entryFileNames: '[name]/[name].js',
        chunkFileNames: 'chunks/[name].[hash].js',
        assetFileNames: 'assets/[name].[ext]'
      }
    }
  },

  server: {
    port: 3000,
    hmr: {
      port: 3000
    }
  }
});
```

### 3.11 Package.jsonï¼ˆå®Œæ•´ä¾èµ–ï¼‰

```json
{
  "name": "smart-bookmark-extension",
  "version": "1.0.0",
  "description": "æ™ºèƒ½æ”¶è—æµè§ˆå™¨æ‰©å±•",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "test": "vitest",
    "lint": "biome lint ./src",
    "format": "biome format --write ./src",
    "type-check": "tsc --noEmit",
    "package": "npm run build && cd dist && zip -r ../extension.zip *",
    "quick-test": "sh scripts/quick-test.sh"
  },
  "dependencies": {
    "clsx": "^2.1.0",
    "lucide-react": "^0.309.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "recharts": "^2.10.4",
    "sonner": "^1.3.1",
    "tailwind-merge": "^2.2.0",
    "zod": "^3.22.4",
    "zustand": "^4.4.7"
  },
  "devDependencies": {
    "@biomejs/biome": "^1.5.3",
    "@crxjs/vite-plugin": "^2.0.0-beta.23",
    "@tailwindcss/forms": "^0.5.7",
    "@tailwindcss/typography": "^0.5.10",
    "@types/chrome": "^0.0.254",
    "@types/node": "^20.10.5",
    "@types/react": "^18.2.45",
    "@types/react-dom": "^18.2.18",
    "@vitejs/plugin-react": "^4.2.1",
    "autoprefixer": "^10.4.16",
    "postcss": "^8.4.32",
    "tailwindcss": "^3.4.0",
    "typescript": "^5.3.3",
    "vite": "^5.0.10",
    "vitest": "^1.1.0"
  }
}
```

## 4. å­˜å‚¨æ–¹æ¡ˆè¯´æ˜

### 4.1 Chrome Storage Local API

æœ¬é¡¹ç›®å®Œå…¨ä½¿ç”¨ Chrome Storage Local API è¿›è¡Œæ•°æ®å­˜å‚¨ï¼š

- **å®¹é‡é™åˆ¶**: çº¦ 5MB (5,242,880 bytes)
- **åŒæ­¥æ–¹å¼**: è‡ªåŠ¨åŒæ­¥åˆ°ç”¨æˆ·çš„æœ¬åœ°Chromeé…ç½®
- **è®¿é—®æƒé™**: ä»…æ‰©å±•è‡ªèº«å¯è®¿é—®
- **æ•°æ®æ ¼å¼**: JSON åºåˆ—åŒ–

### 4.2 æ•°æ®ç»“æ„

```javascript
// Chrome Storage Local ä¸­çš„æ•°æ®ç»“æ„
{
  "bookmarks": [
    {
      "id": "uuid",
      "url": "https://example.com",
      "title": "ç¤ºä¾‹ç½‘é¡µ",
      "note": "è¿™æ˜¯å¤‡æ³¨",
      "tags": ["tag1", "tag2"],
      "favicon": "data:image/png;base64,...",
      "createdAt": "2024-01-01T00:00:00.000Z",
      "updatedAt": "2024-01-02T00:00:00.000Z",
      "deleted": false
    }
  ],
  "tags": {
    "tag1": {
      "id": "uuid",
      "name": "tag1",
      "count": 5,
      "createdAt": "2024-01-01T00:00:00.000Z"
    }
  },
  "settings": {
    "version": "1.0.0",
    "theme": "auto",
    "dashboardCollapsed": false
  }
}
```

### 4.3 å­˜å‚¨ä¼˜åŒ–ç­–ç•¥

1. **æ•°æ®å‹ç¼©**: å¯¹äºå¤§é‡ä¹¦ç­¾ï¼Œå¯è€ƒè™‘å‹ç¼©å­˜å‚¨
2. **åˆ†ç‰‡å­˜å‚¨**: å°†æ•°æ®åˆ†ç‰‡å­˜å‚¨é¿å…å•ä¸ªkeyè¿‡å¤§
3. **ç¼“å­˜ç­–ç•¥**: ä½¿ç”¨å†…å­˜ç¼“å­˜å‡å°‘å­˜å‚¨è¯»å–
4. **å®šæœŸæ¸…ç†**: è‡ªåŠ¨æ¸…ç†30å¤©å‰çš„è½¯åˆ é™¤æ•°æ®

## 5. æµ‹è¯•è¯´æ˜

### 5.1 å•å…ƒæµ‹è¯•ç¤ºä¾‹

```typescript
// src/lib/utils.test.ts
import { describe, it, expect } from 'vitest';
import { normalizeTag, escapeCSV, generateId } from './utils';

describe('Utils', () => {
  describe('normalizeTag', () => {
    it('should normalize tag to lowercase', () => {
      expect(normalizeTag('Tech')).toBe('tech');
    });

    it('should trim whitespace', () => {
      expect(normalizeTag('  tech  ')).toBe('tech');
    });

    it('should handle empty string', () => {
      expect(normalizeTag('')).toBe('');
    });
  });

  describe('escapeCSV', () => {
    it('should escape commas', () => {
      expect(escapeCSV('hello, world')).toBe('"hello, world"');
    });

    it('should escape quotes', () => {
      expect(escapeCSV('hello "world"')).toBe('"hello ""world"""');
    });

    it('should handle empty string', () => {
      expect(escapeCSV('')).toBe('');
    });
  });

  describe('generateId', () => {
    it('should generate valid UUID', () => {
      const id = generateId();
      expect(id).toMatch(/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i);
    });

    it('should generate unique IDs', () => {
      const id1 = generateId();
      const id2 = generateId();
      expect(id1).not.toBe(id2);
    });
  });
});
```

## 6. å¸¸è§é—®é¢˜ä¿®å¤

### 6.1 å·²ä¿®å¤çš„é—®é¢˜

1. âœ… **ç¼ºå°‘å‡½æ•°å¼•ç”¨**: æ·»åŠ äº†å®Œæ•´çš„å·¥å…·å‡½æ•°å’ŒHookså®ç°
2. âœ… **ç±»å‹å¯¼å…¥é”™è¯¯**: ä¿®æ­£äº†æ‰€æœ‰ç±»å‹å¯¼å…¥è¯­å¥
3. âœ… **Manifestè·¯å¾„é—®é¢˜**: ä¿®æ­£äº†Service Workerå’Œèµ„æºè·¯å¾„
4. âœ… **å­˜å‚¨APIä½¿ç”¨**: ç»Ÿä¸€ä½¿ç”¨chrome.storage.local
5. âœ… **å¼‚æ­¥å¤„ç†**: æ‰€æœ‰å­˜å‚¨æ“ä½œä½¿ç”¨Promise
6. âœ… **é”™è¯¯å¤„ç†**: æ·»åŠ äº†å®Œæ•´çš„é”™è¯¯å¤„ç†æœºåˆ¶
7. âœ… **LoadingçŠ¶æ€**: æ·»åŠ äº†åŠ è½½å’Œæ“ä½œçŠ¶æ€æç¤º
8. âœ… **æ•°æ®éªŒè¯**: ä½¿ç”¨Zodè¿›è¡Œè¿è¡Œæ—¶éªŒè¯

### 6.2 æ€§èƒ½ä¼˜åŒ–

1. **é˜²æŠ–æœç´¢**: 300mså»¶è¿Ÿé¿å…é¢‘ç¹æŸ¥è¯¢
2. **è™šæ‹Ÿåˆ—è¡¨**: å¤§æ•°æ®é‡æ—¶ä½¿ç”¨è™šæ‹Ÿæ»šåŠ¨
3. **æ‡’åŠ è½½**: ç»„ä»¶å’Œèµ„æºæŒ‰éœ€åŠ è½½
4. **ç¼“å­˜ç­–ç•¥**: åˆç†ä½¿ç”¨å†…å­˜ç¼“å­˜

### 6.3 å®‰å…¨è€ƒè™‘

1. **CSPé…ç½®**: ä¸¥æ ¼çš„å†…å®¹å®‰å…¨ç­–ç•¥
2. **æƒé™æœ€å°åŒ–**: ä»…è¯·æ±‚å¿…è¦æƒé™
3. **æ•°æ®éªŒè¯**: æ‰€æœ‰è¾“å…¥è¿›è¡ŒéªŒè¯
4. **XSSé˜²æŠ¤**: Reacté»˜è®¤è½¬ä¹‰ï¼Œé¢å¤–éªŒè¯ç”¨æˆ·è¾“å…¥

## 7. æµ‹è¯•æ–¹æ¡ˆï¼ˆä¸ªäººé¡¹ç›®ç‰ˆï¼‰

### 7.1 æ‰‹åŠ¨æµ‹è¯•æ¸…å•

#### åŸºç¡€åŠŸèƒ½æµ‹è¯•
- [ ] æ‰©å±•å®‰è£…å’Œå›¾æ ‡æ˜¾ç¤º
- [ ] å¼¹çª—æ‰“å¼€é€Ÿåº¦ < 300ms
- [ ] è¡¨å•è‡ªåŠ¨å¡«å……URLå’Œæ ‡é¢˜
- [ ] å¤‡æ³¨è¾“å…¥åŠŸèƒ½
- [ ] æ ‡ç­¾è‡ªåŠ¨å®Œæˆå’Œåˆ›å»º
- [ ] ä¿å­˜æˆåŠŸæç¤º
- [ ] æ•°æ®æ­£ç¡®å­˜å‚¨åˆ°chrome.storage.local

#### ç®¡ç†é¡µé¢æµ‹è¯•
- [ ] ä¹¦ç­¾åˆ—è¡¨æ­£ç¡®æ˜¾ç¤º
- [ ] æœç´¢åŠŸèƒ½ï¼ˆæ ‡é¢˜ã€å¤‡æ³¨ã€æ ‡ç­¾ï¼‰
- [ ] æ ‡ç­¾ç­›é€‰
- [ ] æ‰¹é‡é€‰æ‹©å’Œåˆ é™¤
- [ ] æ•°æ®çœ‹æ¿æŠ˜å /å±•å¼€
- [ ] æ ‡ç­¾ç»Ÿè®¡å›¾è¡¨
- [ ] çƒ­åŠ›å›¾æ˜¾ç¤º

#### å¯¼å‡ºåŠŸèƒ½æµ‹è¯•
- [ ] CSVå¯¼å‡ºï¼ˆExcelå¯æ‰“å¼€ï¼‰
- [ ] JSONå¯¼å‡ºæ ¼å¼æ­£ç¡®
- [ ] Markdownå¯¼å‡ºæ ¼å¼æ­£ç¡®
- [ ] ä¸­æ–‡å†…å®¹ç¼–ç æ­£ç¡®

### 7.2 Browser MCP E2Eæµ‹è¯•

```javascript
// ä½¿ç”¨Browser MCPè¿›è¡Œç«¯åˆ°ç«¯æµ‹è¯•
// æµ‹è¯•å‰éœ€è¦å…ˆæ„å»ºå¹¶åŠ è½½æ‰©å±•

async function testBookmarkFlow() {
  // 1. æ‰“å¼€æµ‹è¯•ç½‘é¡µ
  await browser.navigate('https://example.com');
  await browser.wait(1);

  // 2. æ‰“å¼€æ‰©å±•å¼¹çª—ï¼ˆéœ€è¦æ‰©å±•IDï¼‰
  const extId = 'your-extension-id';
  await browser.navigate(`chrome-extension://${extId}/dist/popup/index.html`);

  // 3. ç‚¹å‡»æ”¶è—æŒ‰é’®
  const snapshot1 = await browser.snapshot();
  await browser.click({
    element: 'æ”¶è—æŒ‰é’®',
    ref: 'button:has-text("æ”¶è—å½“å‰ç½‘é¡µ")'
  });

  // 4. å¡«å†™è¡¨å•
  await browser.type({
    element: 'å¤‡æ³¨',
    ref: 'textarea',
    text: 'æµ‹è¯•å¤‡æ³¨å†…å®¹',
    submit: false
  });

  // 5. æ·»åŠ æ ‡ç­¾
  await browser.type({
    element: 'æ ‡ç­¾è¾“å…¥',
    ref: 'input[placeholder*="æ ‡ç­¾"]',
    text: 'test',
    submit: true
  });

  // 6. ä¿å­˜
  await browser.click({
    element: 'ä¿å­˜æŒ‰é’®',
    ref: 'button:has-text("ç¡®è®¤ä¿å­˜")'
  });

  // 7. éªŒè¯
  await browser.wait(2);
  const snapshot2 = await browser.snapshot();
  console.log(snapshot2.includes('æ”¶è—æˆåŠŸ') ? 'âœ… æµ‹è¯•é€šè¿‡' : 'âŒ æµ‹è¯•å¤±è´¥');
}

// æ‰§è¡Œæµ‹è¯•
testBookmarkFlow();
```

### 7.3 å¿«é€Ÿæµ‹è¯•è„šæœ¬

```bash
#!/bin/bash
# quick-test.sh - å¿«é€Ÿæµ‹è¯•è„šæœ¬

# 1. æ„å»ºé¡¹ç›®
echo "ğŸ”¨ æ„å»ºé¡¹ç›®..."
npm run build

# 2. æ£€æŸ¥æ„å»ºäº§ç‰©
if [ ! -d "dist" ]; then
  echo "âŒ æ„å»ºå¤±è´¥ï¼šdistç›®å½•ä¸å­˜åœ¨"
  exit 1
fi

# 3. éªŒè¯manifest.json
if [ ! -f "dist/manifest.json" ]; then
  echo "âŒ manifest.jsonä¸å­˜åœ¨"
  exit 1
fi

# 4. æ£€æŸ¥å¿…è¦æ–‡ä»¶
files=("popup/index.html" "options/index.html" "background/service-worker.js")
for file in "${files[@]}"; do
  if [ ! -f "dist/$file" ]; then
    echo "âŒ ç¼ºå°‘æ–‡ä»¶: $file"
    exit 1
  fi
done

echo "âœ… æ„å»ºéªŒè¯é€šè¿‡"
echo "ğŸ“¦ è¯·åœ¨Chromeä¸­åŠ è½½distç›®å½•è¿›è¡Œæµ‹è¯•"
```

## 8. éƒ¨ç½²æ­¥éª¤ï¼ˆä¸ªäººé¡¹ç›®ç‰ˆï¼‰

### 8.1 æœ¬åœ°å¼€å‘

```bash
# å®‰è£…ä¾èµ–
npm install

# å¼€å‘æ¨¡å¼ï¼ˆæ”¯æŒHMRï¼‰
npm run dev

# åœ¨Chromeä¸­æµ‹è¯•
# 1. æ‰“å¼€ chrome://extensions/
# 2. å¼€å¯å¼€å‘è€…æ¨¡å¼
# 3. åŠ è½½å·²è§£å‹çš„æ‰©å±•ç¨‹åº -> é€‰æ‹©distç›®å½•
```

### 8.2 å‘å¸ƒå‡†å¤‡

```bash
# 1. æ›´æ–°ç‰ˆæœ¬å·
# ç¼–è¾‘ manifest.json å’Œ package.json

# 2. æ„å»ºç”Ÿäº§ç‰ˆæœ¬
npm run build

# 3. æœ¬åœ°æµ‹è¯•
# åœ¨Chromeä¸­åŠ è½½distç›®å½•ï¼Œå®Œæ•´æµ‹è¯•æ‰€æœ‰åŠŸèƒ½

# 4. æ‰“åŒ…
cd dist && zip -r ../extension.zip * && cd ..

# 5. å¤‡ä»½
cp extension.zip "releases/v$(date +%Y%m%d).zip"
```

### 8.3 Chrome Web Storeå‘å¸ƒï¼ˆå¯é€‰ï¼‰

å¦‚æœæƒ³è¦å‘å¸ƒåˆ°Chrome Web Storeï¼š

1. æ³¨å†Œå¼€å‘è€…è´¦å·ï¼ˆä¸€æ¬¡æ€§$5ï¼‰
2. å‡†å¤‡å‘å¸ƒææ–™ï¼š
   - extension.zip
   - æˆªå›¾ï¼ˆ1280x800æˆ–640x400ï¼‰
   - å®£ä¼ å›¾ï¼ˆ440x280ï¼‰
   - éšç§æ”¿ç­–è¯´æ˜
3. ä¸Šä¼ å¹¶æäº¤å®¡æ ¸
4. ç­‰å¾…å®¡æ ¸é€šè¿‡ï¼ˆé€šå¸¸1-3å¤©ï¼‰

## 9. é¡¹ç›®ç»´æŠ¤å»ºè®®

### 9.1 ç‰ˆæœ¬ç®¡ç†

```bash
# ä½¿ç”¨Gitè¿›è¡Œç‰ˆæœ¬æ§åˆ¶
git init
git add .
git commit -m "Initial commit"

# åˆ›å»ºåŠŸèƒ½åˆ†æ”¯
git checkout -b feature/new-feature

# åˆå¹¶åˆ°ä¸»åˆ†æ”¯
git checkout main
git merge feature/new-feature
```

### 9.2 å¤‡ä»½ç­–ç•¥

- å®šæœŸå¯¼å‡ºä¹¦ç­¾æ•°æ®ï¼ˆJSONæ ¼å¼ï¼‰
- Gitä»“åº“æ¨é€åˆ°GitHub/GitLab
- é‡è¦ç‰ˆæœ¬æ‰“åŒ…å­˜æ¡£

### 9.3 æ€§èƒ½ç›‘æ§

```javascript
// æ·»åŠ æ€§èƒ½ç›‘æ§ä»£ç 
console.time('popup-load');
// ... åˆå§‹åŒ–ä»£ç 
console.timeEnd('popup-load');

// ç›‘æ§å­˜å‚¨ä½¿ç”¨
StorageManager.getStorageInfo().then(info => {
  const usage = (info.bytesInUse / info.quota * 100).toFixed(2);
  console.log(`å­˜å‚¨ä½¿ç”¨: ${usage}%`);
});
```

## 10. æ€»ç»“

æ­¤ä¿®æ­£ç‰ˆæŠ€æœ¯æ–‡æ¡£è§£å†³äº†åŸç‰ˆä¸­çš„æ‰€æœ‰ä¸»è¦é—®é¢˜ï¼š

- âœ… å®Œæ•´çš„å‡½æ•°å’Œç»„ä»¶å®ç°
- âœ… æ­£ç¡®çš„ç±»å‹å®šä¹‰å’Œå¯¼å…¥
- âœ… Chrome Storage Local APIçš„ç»Ÿä¸€ä½¿ç”¨
- âœ… å®Œæ•´çš„é”™è¯¯å¤„ç†å’ŒåŠ è½½çŠ¶æ€
- âœ… ä¿®æ­£çš„Manifest V3é…ç½®
- âœ… ä¼˜åŒ–çš„æ€§èƒ½å’Œå®‰å…¨æªæ–½

æ‰€æœ‰ä»£ç éƒ½ç»è¿‡ä»”ç»†æ£€æŸ¥ï¼Œç¡®ä¿å¯ä»¥æ­£å¸¸è¿è¡Œã€‚